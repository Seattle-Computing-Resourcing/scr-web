import Page from '../components/page/Page'

export const meta = {
    title: 'Test',
    description: 'Test',
}

export default ({ children }) => <Page meta={meta}>{children}</Page>;

```js
function sayHello(name) {
  console.log('Hello', name);
}
```

## Introduction<br></br><br></br>
Graph traversal algorithms visit all nodes within a graph in a certain order and can compute some information along the way.
Two common algorithms for doing this are **depth first search (DFS)** and **breadth first search (BFS)**.

### Application: Connected Components


A **connected component** is a maximal set of connected nodes in an undirected
graph. In other words, two nodes are in the same connected component _if and
only if_ they can reach each other via edges in the graph.

In the above focus problem, the goal is to add the minimum possible number of
edges such that the entire graph forms a single connected component.

### Application: Graph Two-Coloring


**Graph two-coloring** refers to assigning a boolean value to each node of the
graph, dictated by the edge configuration. The most common example of a
two-colored graph is a **bipartite graph**, in which each edge connects two
nodes of opposite colors.

In the above focus problem, the goal is to assign each node (friend) of the
graph to one of two colors (teams), subject to the constraint that edges
(friendships) connect two nodes of opposite colors. In other words, we need to
check whether the input is a bipartite graph and output a valid coloring if it
is.

## DFS


From the second resource:

> Depth-first search (DFS) is a straightforward graph traversal technique. The
> algorithm begins at a starting node, and proceeds to all other nodes that are
> reachable from the starting node using the edges of the graph.
>
> Depth-first search always follows a single path in the graph as long as it
> finds new nodes. After this, it returns to previous nodes and begins to
> explore other parts of the graph. The algorithm keeps track of visited nodes,
> so that it processes each node only once.

When implementing DFS, we often use a recursive function to visit the vertices and an array to store whether we've seen a vertex before.


```cpp
#include <bits/stdc++.h>
using namespace std;

int n = 6;
vector<vector<int>> adj(n);
vector<bool> visited(n);

void dfs(int current_node) {
	if (visited[current_node]) { return; }
	visited[current_node] = true;

	for (int neighbor : adj[current_node]) { dfs(neighbor); }
}

int main() {
	/*
	 * Define adjacency list and read in problem-specific input
	 *
	 * In this example, we've provided "dummy input" that's
	 * reflected in the GIF above to help illustrate the
	 * order of the recrusive calls.
	 */
	adj[0] = {1, 2, 4};
	adj[1] = {3, 4};
	adj[2] = {5};

	for (int i = 0; i < n; i++) {
		// iterate over all connected components in the graph
		if (!visited[i]) { dfs(i); }
	}
}
```


```java
import java.io.*;
import java.util.*;

public class DFSDemo {
	static List<Integer>[] adj;
	static boolean[] visited;
	static int n = 6;

	public static void main(String[] args) throws IOException {
		visited = new boolean[n];

		/*
		 * Define adjacency list and read in problem-specific input
		 *
		 * In this example, we've provided "dummy input" that's
		 * reflected in the GIF above to help illustrate the
		 * order of the recrusive calls.
		 */
		adj = new ArrayList[n];
		for (int i = 0; i < n; i++) { adj[i] = new ArrayList<>(); }
		adj[0] = new ArrayList<>(Arrays.asList(1, 2, 4));
		adj[1] = new ArrayList<>(Arrays.asList(3, 4));
		adj[2] = new ArrayList<>(Arrays.asList(5));

		for (int i = 0; i < n; i++) {
			// iterate over all connected components in the graph
			if (!visited[i]) { dfs(i); }
		}
	}

	static void dfs(int currentNode) {
		if (visited[currentNode]) { return; }

		visited[currentNode] = true;
		for (int neighbor : adj[currentNode]) { dfs(neighbor); }
	}
}
```

```py
import sys

sys.setrecursionlimit(10**5)  # Python has a default recursion limit of 1000

n = 6
visited = [False] * n

"""
Define adjacency list and read in problem-specific input here.

In this example, we've provided "dummy input" that's
reflected in the GIF above to help illustrate the
order of the recrusive calls.
"""
adj = [[] for _ in range(n)]
adj[0] = [1, 2, 4]
adj[1] = [3, 4]
adj[2] = [5]


def dfs(current_node):
	visited[current_node] = True
	for neighbor in adj[current_node]:
		if not visited[neighbor]:
			dfs(neighbor)


for i in range(n):
	if not visited[i]:
		dfs(i)
```


## BFS

